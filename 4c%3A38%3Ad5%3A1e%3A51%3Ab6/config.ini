
; Static BURN configuration 

[burnstages]
stages=inv0,bench0,bench1,burn0,burn1,burn2,burn2-readonly,burn3,burn4,leiden1,burn5,burn6,inv1,shutdown

[inv0]
description=INV/System inventory
intrusive=False
always_run=True
long_description=Inventarise all componentes, including add-on cards, firmware versions and serial numbers
command=#!/bin/bash
  mkdir -p ${SPOOLDIR}/outputs/
  source /trinity/shared/apps/identify/venv/bin/activate
  /trinity/shared/apps/identify/identify.py --output ${SPOOLDIR}/outputs/identify.json --email burn@clustervision.com


[inv1]
description=INV/System inventory
intrusive=False
long_description=Inventarise all componentes, including add-on cards, firmware versions and serial numbers
command=#!/bin/bash
  mkdir -p ${SPOOLDIR}/outputs/
  source /trinity/shared/apps/identify/venv/bin/activate
  /trinity/shared/apps/identify/identify.py --output ${SPOOLDIR}/outputs/identify.json --email burn@clustervision.com

[bench0]
description=HW/CPU
intrusive=False
long_description=Runs peakperf to get CPU flops
command=#!/bin/bash
  /trinity/shared/apps/peakperf/peakperf --device cpu | tee ${SPOOLDIR}/outputs/bench0-cpu
  if [ $? -eq 1 ]
  then
    /trinity/shared/apps/peakperf/peakperf --device cpu -b skylake_512 | tee ${SPOOLDIR}/outputs/bench0-cpu
  fi
  for gpu in `ls /dev/nvidia[0-9]* | sed 's/.*nvidia//g'`
  do
    /trinity/shared/apps/peakperf/peakperf --gpu-id $gpu --device gpu | tee ${SPOOLDIR}/outputs/bench0-gpu-$gpu
  done

[bench1]
description=HW/Memory
intrusive=False
long_description=Runs various CPU calculations to maximize heat and verify results
command=#!/bin/bash
   timeout 5m /trinity/shared/apps/stream/stream.exe | tee -a ${SPOOLDIR}/outputs/bench1-stream
   timeout 5m /trinity/shared/apps/stream/stream_omp.exe | tee -a ${SPOOLDIR}/outputs/bench1-stream_omp

[burn0]
description=HW/CPU
intrusive=False
long_description=Runs various CPU calculations to maximize heat and verify results
command=#!/bin/bash
   /usr/bin/ipmitool sel list | tee -a ${SPOOLDIR}/outputs/sel-before-burn
   /usr/bin/ipmitool sel clear
   STARTTIME=`/usr/bin/perl -e 'print time();'`
   echo "Running maxtrix (5m)"
   timeout 6m stress-ng --matrix 0 --matrix-method all -t 5m --metrics-brief --log-file ${SPOOLDIR}/outputs/burn0-stress-ng-matrix
   /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn0-stress-ng-matrix ${SPOOLDIR}
   STARTTIME=`/usr/bin/perl -e 'print time();'`
   echo "Verifying computations (5m)"
   timeout 6m stress-ng --cpu 0 --cpu-method all --verify -t 5m --metrics-brief --log-file ${SPOOLDIR}/outputs/burn0-stress-ng-verify
   /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn0-stress-ng-verify ${SPOOLDIR}
   STARTTIME=`/usr/bin/perl -e 'print time();'`
   echo "Running mprime95 (10m)"
   timeout 10m /trinity/shared/apps/mprime/30.3b6/mprime -t 2>&1 > /dev/null | tee -a ${SPOOLDIR}/outputs/burn0-mprime
   /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn0-mprime ${SPOOLDIR}

[burn1]
description=HW/Memory
intrusive=False
long_descriptions=Run various memory tests to stress memory subsystems
command=#!/bin/bash
   STARTTIME=`/usr/bin/perl -e 'print time();'`
   echo "Running memtest (2h)"
   timeout 61m stress-ng --vm 0 --vm-bytes 90%% -t 1h --vm-method  move-inv --metrics-brief | tee -a ${SPOOLDIR}/outputs/burn1-move-inv
   /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn1-move-inv ${SPOOLDIR}
   STARTTIME=`/usr/bin/perl -e 'print time();'`
   echo "Running memcpy (2h)"
   timeout 61m stress-ng --memcpy 0 -t 1h --metrics-brief | tee -a ${SPOOLDIR}/outputs/burn1-memcpy
   /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn1-memcpy ${SPOOLDIR}

[burn2]
description=HW/Storage
intrusive=True
long_description=Locate all block devices and firmware(s)
command=#!/bin/bash
    echo "Attempting to gather SMART data..."
    for disk in `lsblk | grep disk | awk '{print $1}'`; do /usr/sbin/smartctl -d ata -a /dev/${disk} > ${SPOOLDIR}/outputs/burn2-disk-${disk};done
    echo "Looping disks..."
    declare -a diskarray=()
    declare -a spinningarray=()
    declare -a ssdarray=()
    declare -a nvmearray=()
    for disk in `lsblk | grep disk | awk '{print $1}'`; do
      if `grep -q 1 /sys/block/$disk/queue/rotational`
      then
        spinningarray+=("${disk}")
      elif [[ "$disk" =~ ^nvme.*$ ]]
      then
        nvmearray+=("${disk}")
      else
        ssdarray+=("${disk}")
      fi
      diskarray+=("${disk}")
    done
    lastitem=$(( ${#diskarray[*]} - 1 ))
    if [[ ${#nvmearray[*]} > 0 ]]
    then
      lastdisk=${nvmearray[-1]}
    elif [[ ${#ssdarray[*]} > 0 ]]
    then
      lastdisk=${ssdarray[-1]}
    elif [[ ${#spinningarray[*]} > 0 ]]
    then
      lastdisk=${spinningarray[-1]}
    fi
    i=0
    section=18
    echo "${#spinningarray[*]} spinning disks found"
    echo "${#ssdarray[*]} ssd disks found"
    echo "${#nvmearray[*]} nvme disks found"
    if [[ ${#spinningarray[*]} > $section ]]
    then
      echo "Too many disks for one run."
      if [[ $((${#spinningarray[*]} %% $section)) > 0 ]]
      then
        section=$(( ${#spinningarray[*]} / $section + 1 ))
        echo $section
        section=$(( ${#spinningarray[*]} / $section ))
        if [[ $((${#spinningarray[*]} %% $section)) > 0 ]]
        then
          section=$(( $section + 1 ))
        fi
      else
        section=$(( ${#spinningarray[*]} / $section ))
        section=$(( ${#spinningarray[*]} / $section ))
      fi
    fi
    echo "Sectioning disks into sets of $section disks"
    for ldisk in "${spinningarray[@]}" "${ssdarray[@]}" "${nvmearray[@]}"; do
      if [[ `grep -q ${ldisk} /proc/mounts` ]]; then
        echo "Skipping ${ldisk}"
      else
       let i+=1
       test_array+=("${ldisk}")
      fi
      if [[ $i -eq $section ]] || [[ "${ldisk}" == "${lastdisk}" ]] ; then
        echo "Starting (max) ${section} disk tests on ${test_array[*]}"
        for tdisk in "${test_array[@]}"; do
          dd if=/dev/zero of=/dev/${tdisk} oflag=direct bs=1M 2>&1 | tee ${SPOOLDIR}/outputs/burn2-${tdisk} &
        done
        wait
        test_array=()
      i=0
      fi
    done
    echo "Attempting to auto-update Intel SSD firmwares"
    /usr/bin/intelmas show -intelssd > ${SPOOLDIR}/outputs/burn2-intelssd
    for intelssd in `/usr/bin/intelmas show -intelssd | grep Index | awk '{print $3}'`; do /usr/bin/intelmas load -f -intelssd ${intelssd};done

[burn2-readonly]
description=HW/Storage
intrusive=False
long_description=Locate all block devices and firmware(s)
command=#!/bin/bash
    STARTTIME=`/usr/bin/perl -e 'print time();'`
    echo "Looping disks..."
    declare -a diskarray=()
    declare -a spinningarray=()
    declare -a ssdarray=()
    declare -a nvmearray=()
    for disk in `lsblk | grep disk | awk '{print $1}'`; do
      if `grep -q 1 /sys/block/$disk/queue/rotational`
      then
        spinningarray+=("${disk}")
      elif [[ "$disk" =~ ^nvme.*$ ]]
      then
        nvmearray+=("${disk}")
      else
        ssdarray+=("${disk}")
      fi
      diskarray+=("${disk}")
    done
    lastitem=$(( ${#diskarray[*]} - 1 ))
    if [[ ${#nvmearray[*]} > 0 ]]
    then
      lastdisk=${nvmearray[-1]}
    elif [[ ${#ssdarray[*]} > 0 ]]
    then
      lastdisk=${ssdarray[-1]}
    elif [[ ${#spinningarray[*]} > 0 ]]
    then
      lastdisk=${spinningarray[-1]}
    fi
    i=0
    section=18
    echo "${#spinningarray[*]} spinning disks found"
    echo "${#ssdarray[*]} ssd disks found"
    echo "${#nvmearray[*]} nvme disks found"
    if [[ ${#spinningarray[*]} > $section ]]
    then
      echo "Too many disks for one run."
      if [[ $((${#spinningarray[*]} %% $section)) > 0 ]]
      then
        section=$(( ${#spinningarray[*]} / $section + 1 ))
        echo $section
        section=$(( ${#spinningarray[*]} / $section ))
        if [[ $((${#spinningarray[*]} %% $section)) > 0 ]]
        then
          section=$(( $section + 1 ))
        fi
      else
        section=$(( ${#spinningarray[*]} / $section ))
        section=$(( ${#spinningarray[*]} / $section ))
      fi
    fi
    echo "Sectioning disks into sets of $section disks"
    for ldisk in "${spinningarray[@]}" "${ssdarray[@]}" "${nvmearray[@]}"; do
      if [[ `grep -q ${ldisk} /proc/mounts` ]]; then
        echo "Skipping ${ldisk}"
      else
       let i+=1
       test_array+=("${ldisk}")
      fi
      if [[ $i -eq $section ]] || [[ "${ldisk}" == "${lastdisk}" ]] ; then
        echo "Starting (max) ${section} disk tests on ${test_array[*]}"
        for tdisk in "${test_array[@]}"; do
          dd of=/dev/null if=/dev/${tdisk} iflag=direct bs=1M 2>&1 | tee ${SPOOLDIR}/outputs/burn2-readonly-${tdisk} &
        done
        wait
        test_array=()
      i=0
      fi
    done
    /trinity/shared/apps/graph/disk.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn2-readonly ${SPOOLDIR}

[burn3]
description=HW/Interconnect
intrusive=False
long_description=Check all Ethernet, InfiniBand connections
command=#!/bin/bash
    ibv_devinfo | tee -a ${SPOOLDIR}/outputs/burn3-ib

[burn4]
description=HW/GPGPU
intrusive=False
long_description=Run GPU burn test on all CUDA-capable cards
command=#!/bin/bash
    if [ -c /dev/nvidia0 ]
    then 
        STARTTIME=`/usr/bin/perl -e 'print time();'`
        nvidia-smi | tee -a ${SPOOLDIR}/outputs/burn5-nvidia-smi
        cd /trinity/shared/apps/gpu-burn
        timeout 7260s ./gpu_burn 7200 | tee -a ${SPOOLDIR}/outputs/burn5-gpu_burn
        /trinity/shared/apps/graph/gpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn4 ${SPOOLDIR}
    fi

[leiden1]
description=HW/GPGPU
intrusive=False
long_description=Run GPU benchmark for Leiden
command=#!/bin/bash
    if [ -c /dev/nvidia0 ]
    then
        sudo -u daniel bash -c 'source ~/.bashrc && conda init bash && conda activate tf  && /trinity/home/daniel/bench.sh' | tee -a ${SPOOLDIR}/outputs/leiden1-benchmark
    fi

[burn5]
description=Completion
intrusive=False
long_description=Burn completed, run memory test for an additional 8 hours
command=#!/bin/bash
    STARTTIME=`/usr/bin/perl -e 'print time();'`
    echo "Running memtest (8h)"
    timeout 121m stress-ng --vm 0 --vm-bytes 90%% -t 2h  --vm-method  move-inv --metrics-brief | tee -a ${SPOOLDIR}/outputs/burn5-move-inv
    /trinity/shared/apps/graph/cpu.sh ${STARTTIME} `/usr/bin/perl -e 'print time();'` `hostname -f` burn5-move-inv ${SPOOLDIR}

[burn6]
description=HW/IPMI/BMC tests
intrusive=False
long_description=Locate BMC and firmware(s) and perform power cycles
command=#!/bin/bash
    if [ ! -f ${SPOOLDIR}/cycle ]; then echo 0 > ${SPOOLDIR}/cycle; fi
    CYCLECOUNT=`cat ${SPOOLDIR}/cycle`
    let CYCLECOUNT+=1
    echo $CYCLECOUNT > ${SPOOLDIR}/cycle
    echo "Cycling ${CYCLECOUNT}..."
    sleep 10
    if [ ${CYCLECOUNT} -ge 3 ]; then touch ${SPOOLDIR}/burn6.completed; else /usr/bin/ipmitool power reset; fi
    sleep 60

[shutdown]
description=Shutdown after burn and last log
intrusive=False
long_description=Shutdown system once burn is completed to avoid noise.
command=#!/bin/bash
    /usr/bin/ipmitool sel list | tee -a ${SPOOLDIR}/outputs/sel-log
    /usr/bin/touch ${SPOOLDIR}/shutdown.completed
    /usr/sbin/shutdown --poweroff &
